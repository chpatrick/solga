<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.ByteString.Search.DFA</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Data-ByteString-Search-DFA.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">stringsearch-0.3.6.6: Fast searching, splitting and replacing of ByteStrings</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>Daniel Fischer</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>Daniel Fischer &lt;daniel.is.fischer@googlemail.com&gt;</td></tr><tr><th>Stability</th><td>Provisional</td></tr><tr><th>Portability</th><td>non-portable (BangPatterns)</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Data.ByteString.Search.DFA</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Overview</a><ul><li><a href="#g:2">Complexity and performance</a></li><li><a href="#g:3">Partial application</a></li></ul></li><li><a href="#g:4">Finding substrings</a></li><li><a href="#g:5">Breaking on substrings</a></li><li><a href="#g:6">Replacing</a></li><li><a href="#g:7">Splitting</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Fast search of strict <code><a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></code> values. Breaking, splitting and
 replacing using a deterministic finite automaton.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:indices">indices</a> :: <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; [<a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a>]</li><li class="src short"><a href="#v:nonOverlappingIndices">nonOverlappingIndices</a> :: <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; [<a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a>]</li><li class="src short"><a href="#v:breakOn">breakOn</a> :: <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; (<a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a>, <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a>)</li><li class="src short"><a href="#v:breakAfter">breakAfter</a> :: <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; (<a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a>, <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a>)</li><li class="src short"><a href="#v:replace">replace</a> :: <a href="Data-ByteString-Search-Substitution.html#t:Substitution">Substitution</a> rep =&gt; <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; rep -&gt; <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../bytestring-0.10.6.0/Data-ByteString-Lazy.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:split">split</a> :: <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; [<a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a>]</li><li class="src short"><a href="#v:splitKeepEnd">splitKeepEnd</a> :: <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; [<a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a>]</li><li class="src short"><a href="#v:splitKeepFront">splitKeepFront</a> :: <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; [<a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a>]</li></ul></div><div id="interface"><h1 id="g:1">Overview</h1><div class="doc"><p>This module provides functions related to searching a substring within
 a string. The searching algorithm uses a deterministic finite automaton
 based on the Knuth-Morris-Pratt algorithm.
 The automaton is implemented as an array of <code>(patternLength + 1) * &#963;</code>
 state transitions, where &#963; is the alphabet size (256), so it is
 only suitable for short enough patterns.</p><p>When searching a pattern in a UTF-8-encoded <code><a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></code>, be aware that
 these functions work on bytes, not characters, so the indices are
 byte-offsets, not character offsets.</p></div><h2 id="g:2">Complexity and performance</h2><div class="doc"><p>The time and space complexity of the preprocessing phase is
 <em>O</em>(<code>patternLength * &#963;</code>).
 The searching phase is <em>O</em>(<code>targetLength</code>), each target character is
 inspected only once.</p><p>In general the functions in this module are slightly faster than the
 corresponding functions using the Knuth-Morris-Pratt algorithm but
 considerably slower than the Boyer-Moore functions. For very short
 patterns or, in the case of <code><a href="Data-ByteString-Search-DFA.html#v:indices">indices</a></code>, patterns with a short period
 which occur often, however, times are close to or even below the
 Boyer-Moore times.</p></div><h2 id="g:3">Partial application</h2><div class="doc"><p>All functions can usefully be partially applied. Given only a pattern,
 the automaton is constructed only once, allowing efficient re-use.</p></div><h1 id="g:4">Finding substrings</h1><div class="top"><p class="src"><a name="v:indices" class="def">indices</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>Pattern to find</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>String to search</p></td></tr><tr><td class="src">-&gt; [<a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a>]</td><td class="doc"><p>Offsets of matches</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Search-DFA.html#v:indices">indices</a></code></code> finds the starting indices of all possibly overlapping
   occurrences of the pattern in the target string.
   If the pattern is empty, the result is <code>[0 .. <code><a href="../base-4.8.2.0/Data-Foldable.html#v:length">length</a></code> target]</code>.</p></div></div><div class="top"><p class="src"><a name="v:nonOverlappingIndices" class="def">nonOverlappingIndices</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>Pattern to find</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>String to search</p></td></tr><tr><td class="src">-&gt; [<a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a>]</td><td class="doc"><p>Offsets of matches</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Search-DFA.html#v:nonOverlappingIndices">nonOverlappingIndices</a></code></code> finds the starting indices of all
   non-overlapping occurrences of the pattern in the target string.
   It is more efficient than removing indices from the list produced
   by <code><a href="Data-ByteString-Search-DFA.html#v:indices">indices</a></code>.</p></div></div><h1 id="g:5">Breaking on substrings</h1><div class="top"><p class="src"><a name="v:breakOn" class="def">breakOn</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>String to search for</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>String to search in</p></td></tr><tr><td class="src">-&gt; (<a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a>, <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a>)</td><td class="doc"><p>Head and tail of string broken at substring</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Search-DFA.html#v:breakOn">breakOn</a></code> pattern target</code> splits <code>target</code> at the first occurrence
   of <code>pattern</code>. If the pattern does not occur in the target, the
   second component of the result is empty, otherwise it starts with
   <code>pattern</code>. If the pattern is empty, the first component is empty.</p><pre>  <code><a href="../base-4.8.2.0/Data-Tuple.html#v:uncurry">uncurry</a></code> <code><a href="../bytestring-0.10.6.0/Data-ByteString.html#v:append">append</a></code> . <code><a href="Data-ByteString-Search-DFA.html#v:breakOn">breakOn</a></code> pattern = <code><a href="../base-4.8.2.0/Data-Function.html#v:id">id</a></code>
</pre></div></div><div class="top"><p class="src"><a name="v:breakAfter" class="def">breakAfter</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>String to search for</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>String to search in</p></td></tr><tr><td class="src">-&gt; (<a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a>, <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a>)</td><td class="doc"><p>Head and tail of string broken after substring</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Search-DFA.html#v:breakAfter">breakAfter</a></code> pattern target</code> splits <code>target</code> behind the first occurrence
   of <code>pattern</code>. An empty second component means that either the pattern
   does not occur in the target or the first occurrence of pattern is at
   the very end of target. To discriminate between those cases, use e.g.
   <code><a href="../bytestring-0.10.6.0/Data-ByteString.html#v:isSuffixOf">isSuffixOf</a></code>.</p><pre>  <code><a href="../base-4.8.2.0/Data-Tuple.html#v:uncurry">uncurry</a></code> <code><a href="../bytestring-0.10.6.0/Data-ByteString.html#v:append">append</a></code> . <code><a href="Data-ByteString-Search-DFA.html#v:breakAfter">breakAfter</a></code> pattern = <code><a href="../base-4.8.2.0/Data-Function.html#v:id">id</a></code>
</pre></div></div><h1 id="g:6">Replacing</h1><div class="top"><p class="src"><a name="v:replace" class="def">replace</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Data-ByteString-Search-Substitution.html#t:Substitution">Substitution</a> rep</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>Substring to replace</p></td></tr><tr><td class="src">-&gt; rep</td><td class="doc"><p>Replacement string</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>String to modify</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.10.6.0/Data-ByteString-Lazy.html#t:ByteString">ByteString</a></td><td class="doc"><p>Lazy result</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Search-DFA.html#v:replace">replace</a></code> pat sub text</code> replaces all (non-overlapping) occurrences of
   <code>pat</code> in <code>text</code> with <code>sub</code>. If occurrences of <code>pat</code> overlap, the first
   occurrence that does not overlap with a replaced previous occurrence
   is substituted. Occurrences of <code>pat</code> arising from a substitution
   will not be substituted. For example:</p><pre>  <code><a href="Data-ByteString-Search-DFA.html#v:replace">replace</a></code> &quot;ana&quot; &quot;olog&quot; &quot;banana&quot; = &quot;bologna&quot;
  <code><a href="Data-ByteString-Search-DFA.html#v:replace">replace</a></code> &quot;ana&quot; &quot;o&quot; &quot;bananana&quot; = &quot;bono&quot;
  <code><a href="Data-ByteString-Search-DFA.html#v:replace">replace</a></code> &quot;aab&quot; &quot;abaa&quot; &quot;aaabb&quot; = &quot;aabaab&quot;
</pre><p>The result is a <em>lazy</em> <code><a href="../bytestring-0.10.6.0/Data-ByteString-Lazy.html#t:ByteString">ByteString</a></code>,
   which is lazily produced, without copying.
   Equality of pattern and substitution is not checked, but</p><pre>  <code><a href="../bytestring-0.10.6.0/Data-ByteString.html#v:concat">concat</a></code> . <code><a href="../bytestring-0.10.6.0/Data-ByteString-Lazy.html#v:toChunks">toChunks</a></code> $ <code><a href="Data-ByteString-Search-DFA.html#v:replace">replace</a></code> pat pat text == text
</pre><p>holds. If the pattern is empty but not the substitution, the result
   is equivalent to (were they <code><a href="../base-4.8.2.0/Data-String.html#t:String">String</a></code>s) <code><code><a href="../base-4.8.2.0/GHC-OldList.html#v:cycle">cycle</a></code> sub</code>.</p><p>For non-empty <code>pat</code> and <code>sub</code> a strict <code><a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></code>,</p><pre>  <code><a href="../bytestring-0.10.6.0/Data-ByteString-Lazy.html#v:fromChunks">fromChunks</a></code> . <code><a href="../base-4.8.2.0/Data-List.html#v:intersperse">intersperse</a></code> sub . <code><a href="Data-ByteString-Search-DFA.html#v:split">split</a></code> pat = <code><a href="Data-ByteString-Search-DFA.html#v:replace">replace</a></code> pat sub
</pre><p>and analogous relations hold for other types of <code>sub</code>.</p></div></div><h1 id="g:7">Splitting</h1><div class="top"><p class="src"><a name="v:split" class="def">split</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>Pattern to split on</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>String to split</p></td></tr><tr><td class="src">-&gt; [<a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a>]</td><td class="doc"><p>Fragments of string</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Search-DFA.html#v:split">split</a></code> pattern target</code> splits <code>target</code> at each (non-overlapping)
   occurrence of <code>pattern</code>, removing <code>pattern</code>. If <code>pattern</code> is empty,
   the result is an infinite list of empty <code><a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></code>s, if <code>target</code>
   is empty but not <code>pattern</code>, the result is an empty list, otherwise
   the following relations hold:</p><pre>  <code><a href="../bytestring-0.10.6.0/Data-ByteString.html#v:concat">concat</a></code> . <code><a href="../base-4.8.2.0/Data-List.html#v:intersperse">intersperse</a></code> pat . <code><a href="Data-ByteString-Search-DFA.html#v:split">split</a></code> pat = <code><a href="../base-4.8.2.0/Data-Function.html#v:id">id</a></code>,
  <code><a href="../base-4.8.2.0/Data-Foldable.html#v:length">length</a></code> (<code><a href="Data-ByteString-Search-DFA.html#v:split">split</a></code> pattern target) ==
              <code><a href="../base-4.8.2.0/Data-Foldable.html#v:length">length</a></code> (<code><a href="Data-ByteString-Search-DFA.html#v:nonOverlappingIndices">nonOverlappingIndices</a></code> pattern target) + 1,
</pre><p>no fragment in the result contains an occurrence of <code>pattern</code>.</p></div></div><div class="top"><p class="src"><a name="v:splitKeepEnd" class="def">splitKeepEnd</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>Pattern to split on</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>String to split</p></td></tr><tr><td class="src">-&gt; [<a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a>]</td><td class="doc"><p>Fragments of string</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Search-DFA.html#v:splitKeepEnd">splitKeepEnd</a></code> pattern target</code> splits <code>target</code> after each (non-overlapping)
   occurrence of <code>pattern</code>. If <code>pattern</code> is empty, the result is an
   infinite list of empty <code><a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></code>s, otherwise the following
   relations hold:</p><pre>  <code><a href="../bytestring-0.10.6.0/Data-ByteString.html#v:concat">concat</a></code> . <code><a href="Data-ByteString-Search-DFA.html#v:splitKeepEnd">splitKeepEnd</a></code> pattern = <code><a href="../base-4.8.2.0/Data-Function.html#v:id">id</a></code>,
</pre><p>all fragments in the result except possibly the last end with
   <code>pattern</code>, no fragment contains more than one occurrence of <code>pattern</code>.</p></div></div><div class="top"><p class="src"><a name="v:splitKeepFront" class="def">splitKeepFront</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>Pattern to split on</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>String to split</p></td></tr><tr><td class="src">-&gt; [<a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a>]</td><td class="doc"><p>Fragments of string</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Search-DFA.html#v:splitKeepFront">splitKeepFront</a></code></code> is like <code><a href="Data-ByteString-Search-DFA.html#v:splitKeepEnd">splitKeepEnd</a></code>, except that <code>target</code> is split
   before each occurrence of <code>pattern</code> and hence all fragments
   with the possible exception of the first begin with <code>pattern</code>.
   No fragment contains more than one non-overlapping occurrence
   of <code>pattern</code>.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>