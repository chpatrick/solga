<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.Aeson.Parser</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Data-Aeson-Parser.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">aeson-0.11.2.0: Fast JSON parsing and encoding</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>(c) 2012-2016 Bryan O'Sullivan
              (c) 2011 MailRank, Inc.</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>Bryan O'Sullivan &lt;bos@serpentine.com&gt;</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Data.Aeson.Parser</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Lazy parsers</a></li><li><a href="#g:2">Strict parsers</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Efficiently and correctly parse a JSON string.  The string must be
 encoded as UTF-8.</p><p>It can be useful to think of parsing as occurring in two phases:</p><ul><li>Identification of the textual boundaries of a JSON value.  This
   is always strict, so that an invalid JSON document can be
   rejected as soon as possible.</li><li>Conversion of a JSON value to a Haskell value.  This may be
   either immediate (strict) or deferred (lazy); see below for
   details.</li></ul><p>The question of whether to choose a lazy or strict parser is
 subtle, but it can have significant performance implications,
 resulting in changes in CPU use and memory footprint of 30% to 50%,
 or occasionally more.  Measure the performance of your application
 with each!</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:json">json</a> :: <a href="../attoparsec-0.13.0.2/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="Data-Aeson-Types.html#t:Value">Value</a></li><li class="src short"><a href="#v:value">value</a> :: <a href="../attoparsec-0.13.0.2/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="Data-Aeson-Types.html#t:Value">Value</a></li><li class="src short"><a href="#v:jstring">jstring</a> :: <a href="../attoparsec-0.13.0.2/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../text-1.2.2.1/Data-Text.html#t:Text">Text</a></li><li class="src short"><a href="#v:json-39-">json'</a> :: <a href="../attoparsec-0.13.0.2/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="Data-Aeson-Types.html#t:Value">Value</a></li><li class="src short"><a href="#v:value-39-">value'</a> :: <a href="../attoparsec-0.13.0.2/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="Data-Aeson-Types.html#t:Value">Value</a></li></ul></div><div id="interface"><h1 id="g:1">Lazy parsers</h1><div class="doc"><p>The <code><a href="Data-Aeson-Parser.html#v:json">json</a></code> and <code><a href="Data-Aeson-Parser.html#v:value">value</a></code> parsers decouple identification from
 conversion.  Identification occurs immediately (so that an invalid
 JSON document can be rejected as early as possible), but conversion
 to a Haskell value is deferred until that value is needed.</p><p>This decoupling can be time-efficient if only a smallish subset of
 elements in a JSON value need to be inspected, since the cost of
 conversion is zero for uninspected elements.  The trade off is an
 increase in memory usage, due to allocation of thunks for values
 that have not yet been converted.</p></div><div class="top"><p class="src"><a name="v:json" class="def">json</a> :: <a href="../attoparsec-0.13.0.2/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="Data-Aeson-Types.html#t:Value">Value</a></p><div class="doc"><p>Parse a top-level JSON value.</p><p>The conversion of a parsed value to a Haskell value is deferred
 until the Haskell value is needed.  This may improve performance if
 only a subset of the results of conversions are needed, but at a
 cost in thunk allocation.</p><p>This function is an alias for <code><a href="Data-Aeson-Parser.html#v:value">value</a></code>. In aeson 0.8 and earlier, it
 parsed only object or array types, in conformance with the
 now-obsolete RFC 4627.</p></div></div><div class="top"><p class="src"><a name="v:value" class="def">value</a> :: <a href="../attoparsec-0.13.0.2/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="Data-Aeson-Types.html#t:Value">Value</a></p><div class="doc"><p>Parse any JSON value.  You should usually <code><a href="Data-Aeson-Parser.html#v:json">json</a></code> in preference to
 this function, as this function relaxes the object-or-array
 requirement of RFC 4627.</p><p>In particular, be careful in using this function if you think your
 code might interoperate with Javascript.  A na&#239;ve Javascript
 library that parses JSON data using <code>eval</code> is vulnerable to attack
 unless the encoded data represents an object or an array.  JSON
 implementations in other languages conform to that same restriction
 to preserve interoperability and security.</p></div></div><div class="top"><p class="src"><a name="v:jstring" class="def">jstring</a> :: <a href="../attoparsec-0.13.0.2/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../text-1.2.2.1/Data-Text.html#t:Text">Text</a></p><div class="doc"><p>Parse a quoted JSON string.</p></div></div><h1 id="g:2">Strict parsers</h1><div class="doc"><p>The <code><a href="Data-Aeson-Parser.html#v:json-39-">json'</a></code> and <code><a href="Data-Aeson-Parser.html#v:value-39-">value'</a></code> parsers combine identification with
 conversion.  They consume more CPU cycles up front, but have a
 smaller memory footprint.</p></div><div class="top"><p class="src"><a name="v:json-39-" class="def">json'</a> :: <a href="../attoparsec-0.13.0.2/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="Data-Aeson-Types.html#t:Value">Value</a></p><div class="doc"><p>Parse a top-level JSON value.</p><p>This is a strict version of <code><a href="Data-Aeson-Parser.html#v:json">json</a></code> which avoids building up thunks
 during parsing; it performs all conversions immediately.  Prefer
 this version if most of the JSON data needs to be accessed.</p><p>This function is an alias for <code><a href="Data-Aeson-Parser.html#v:value-39-">value'</a></code>. In aeson 0.8 and earlier, it
 parsed only object or array types, in conformance with the
 now-obsolete RFC 4627.</p></div></div><div class="top"><p class="src"><a name="v:value-39-" class="def">value'</a> :: <a href="../attoparsec-0.13.0.2/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="Data-Aeson-Types.html#t:Value">Value</a></p><div class="doc"><p>Strict version of <code><a href="Data-Aeson-Parser.html#v:value">value</a></code>. See also <code><a href="Data-Aeson-Parser.html#v:json-39-">json'</a></code>.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>