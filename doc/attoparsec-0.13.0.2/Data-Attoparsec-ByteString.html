<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.Attoparsec.ByteString</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Data-Attoparsec-ByteString.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">attoparsec-0.13.0.2: Fast combinator parsing for bytestrings and text</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>Bryan O'Sullivan 2007-2015</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>bos@serpentine.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>unknown</td></tr><tr><th>Safe Haskell</th><td>Trustworthy</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Data.Attoparsec.ByteString</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Differences from Parsec</a></li><li><a href="#g:2">Incremental input</a></li><li><a href="#g:3">Performance considerations</a></li><li><a href="#g:4">Parser types</a></li><li><a href="#g:5">Running parsers</a><ul><li><a href="#g:6">Result conversion</a></li></ul></li><li><a href="#g:7">Parsing individual bytes</a><ul><li><a href="#g:8">Lookahead</a></li><li><a href="#g:9">Byte classes</a></li></ul></li><li><a href="#g:10">Efficient string handling</a><ul><li><a href="#g:11">Consume all remaining input</a></li></ul></li><li><a href="#g:12">Combinators</a></li><li><a href="#g:13">State observation and manipulation functions</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Simple, efficient combinator parsing for <code><a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></code> strings,
 loosely based on the Parsec library.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">type</span> <a href="#t:Parser">Parser</a> = <a href="Data-Attoparsec-Internal-Types.html#t:Parser">Parser</a> <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:Result">Result</a> = <a href="Data-Attoparsec-ByteString.html#t:IResult">IResult</a> <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:IResult">IResult</a> i r<ul class="subs"><li>= <a href="#v:Fail">Fail</a> i [<a href="../base-4.8.2.0/Data-String.html#t:String">String</a>] <a href="../base-4.8.2.0/Data-String.html#t:String">String</a></li><li>| <a href="#v:Partial">Partial</a> (i -&gt; <a href="Data-Attoparsec-ByteString.html#t:IResult">IResult</a> i r)</li><li>| <a href="#v:Done">Done</a> i r</li></ul></li><li class="src short"><a href="#v:compareResults">compareResults</a> :: (<a href="../base-4.8.2.0/Data-Eq.html#t:Eq">Eq</a> i, <a href="../base-4.8.2.0/Data-Eq.html#t:Eq">Eq</a> r) =&gt; <a href="Data-Attoparsec-ByteString.html#t:IResult">IResult</a> i r -&gt; <a href="Data-Attoparsec-ByteString.html#t:IResult">IResult</a> i r -&gt; <a href="../base-4.8.2.0/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:parse">parse</a> :: <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> a -&gt; <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="Data-Attoparsec-ByteString.html#t:Result">Result</a> a</li><li class="src short"><a href="#v:feed">feed</a> :: <a href="../base-4.8.2.0/Data-Monoid.html#t:Monoid">Monoid</a> i =&gt; <a href="Data-Attoparsec-ByteString.html#t:IResult">IResult</a> i r -&gt; i -&gt; <a href="Data-Attoparsec-ByteString.html#t:IResult">IResult</a> i r</li><li class="src short"><a href="#v:parseOnly">parseOnly</a> :: <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> a -&gt; <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/Data-Either.html#t:Either">Either</a> <a href="../base-4.8.2.0/Data-String.html#t:String">String</a> a</li><li class="src short"><a href="#v:parseWith">parseWith</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; m <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> a -&gt; <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; m (<a href="Data-Attoparsec-ByteString.html#t:Result">Result</a> a)</li><li class="src short"><a href="#v:parseTest">parseTest</a> :: <a href="../base-4.8.2.0/Text-Show.html#t:Show">Show</a> a =&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> a -&gt; <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:maybeResult">maybeResult</a> :: <a href="Data-Attoparsec-ByteString.html#t:Result">Result</a> r -&gt; <a href="../base-4.8.2.0/Data-Maybe.html#t:Maybe">Maybe</a> r</li><li class="src short"><a href="#v:eitherResult">eitherResult</a> :: <a href="Data-Attoparsec-ByteString.html#t:Result">Result</a> r -&gt; <a href="../base-4.8.2.0/Data-Either.html#t:Either">Either</a> <a href="../base-4.8.2.0/Data-String.html#t:String">String</a> r</li><li class="src short"><a href="#v:word8">word8</a> :: <a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a></li><li class="src short"><a href="#v:anyWord8">anyWord8</a> :: <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a></li><li class="src short"><a href="#v:notWord8">notWord8</a> :: <a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a></li><li class="src short"><a href="#v:satisfy">satisfy</a> :: (<a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a></li><li class="src short"><a href="#v:satisfyWith">satisfyWith</a> :: (<a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a> -&gt; a) -&gt; (a -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> a</li><li class="src short"><a href="#v:skip">skip</a> :: (<a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> ()</li><li class="src short"><a href="#v:peekWord8">peekWord8</a> :: <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> (<a href="../base-4.8.2.0/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a>)</li><li class="src short"><a href="#v:peekWord8-39-">peekWord8'</a> :: <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a></li><li class="src short"><a href="#v:inClass">inClass</a> :: <a href="../base-4.8.2.0/Data-String.html#t:String">String</a> -&gt; <a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:notInClass">notInClass</a> :: <a href="../base-4.8.2.0/Data-String.html#t:String">String</a> -&gt; <a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:string">string</a> :: <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:skipWhile">skipWhile</a> :: (<a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> ()</li><li class="src short"><a href="#v:take">take</a> :: <a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a> -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:scan">scan</a> :: s -&gt; (s -&gt; <a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/Data-Maybe.html#t:Maybe">Maybe</a> s) -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:runScanner">runScanner</a> :: s -&gt; (s -&gt; <a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/Data-Maybe.html#t:Maybe">Maybe</a> s) -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> (<a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a>, s)</li><li class="src short"><a href="#v:takeWhile">takeWhile</a> :: (<a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:takeWhile1">takeWhile1</a> :: (<a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:takeTill">takeTill</a> :: (<a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:takeByteString">takeByteString</a> :: <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:takeLazyByteString">takeLazyByteString</a> :: <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.6.0/Data-ByteString-Lazy.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:try">try</a> :: <a href="Data-Attoparsec-Internal-Types.html#t:Parser">Parser</a> i a -&gt; <a href="Data-Attoparsec-Internal-Types.html#t:Parser">Parser</a> i a</li><li class="src short"><a href="#v:-60--63--62-">(&lt;?&gt;)</a> :: <a href="Data-Attoparsec-Internal-Types.html#t:Parser">Parser</a> i a -&gt; <a href="../base-4.8.2.0/Data-String.html#t:String">String</a> -&gt; <a href="Data-Attoparsec-Internal-Types.html#t:Parser">Parser</a> i a</li><li class="src short"><a href="#v:choice">choice</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Alternative">Alternative</a> f =&gt; [f a] -&gt; f a</li><li class="src short"><a href="#v:count">count</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a> -&gt; m a -&gt; m [a]</li><li class="src short"><a href="#v:option">option</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Alternative">Alternative</a> f =&gt; a -&gt; f a -&gt; f a</li><li class="src short"><a href="#v:many-39-">many'</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:MonadPlus">MonadPlus</a> m =&gt; m a -&gt; m [a]</li><li class="src short"><a href="#v:many1">many1</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Alternative">Alternative</a> f =&gt; f a -&gt; f [a]</li><li class="src short"><a href="#v:many1-39-">many1'</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:MonadPlus">MonadPlus</a> m =&gt; m a -&gt; m [a]</li><li class="src short"><a href="#v:manyTill">manyTill</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Alternative">Alternative</a> f =&gt; f a -&gt; f b -&gt; f [a]</li><li class="src short"><a href="#v:manyTill-39-">manyTill'</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:MonadPlus">MonadPlus</a> m =&gt; m a -&gt; m b -&gt; m [a]</li><li class="src short"><a href="#v:sepBy">sepBy</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Alternative">Alternative</a> f =&gt; f a -&gt; f s -&gt; f [a]</li><li class="src short"><a href="#v:sepBy-39-">sepBy'</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:MonadPlus">MonadPlus</a> m =&gt; m a -&gt; m s -&gt; m [a]</li><li class="src short"><a href="#v:sepBy1">sepBy1</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Alternative">Alternative</a> f =&gt; f a -&gt; f s -&gt; f [a]</li><li class="src short"><a href="#v:sepBy1-39-">sepBy1'</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:MonadPlus">MonadPlus</a> m =&gt; m a -&gt; m s -&gt; m [a]</li><li class="src short"><a href="#v:skipMany">skipMany</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Alternative">Alternative</a> f =&gt; f a -&gt; f ()</li><li class="src short"><a href="#v:skipMany1">skipMany1</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Alternative">Alternative</a> f =&gt; f a -&gt; f ()</li><li class="src short"><a href="#v:eitherP">eitherP</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Alternative">Alternative</a> f =&gt; f a -&gt; f b -&gt; f (<a href="../base-4.8.2.0/Data-Either.html#t:Either">Either</a> a b)</li><li class="src short"><a href="#v:match">match</a> :: <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> a -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> (<a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a>, a)</li><li class="src short"><a href="#v:endOfInput">endOfInput</a> :: <span class="keyword">forall</span> t. <a href="Data-Attoparsec-Internal-Types.html#t:Chunk">Chunk</a> t =&gt; <a href="Data-Attoparsec-Internal-Types.html#t:Parser">Parser</a> t ()</li><li class="src short"><a href="#v:atEnd">atEnd</a> :: <a href="Data-Attoparsec-Internal-Types.html#t:Chunk">Chunk</a> t =&gt; <a href="Data-Attoparsec-Internal-Types.html#t:Parser">Parser</a> t <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a></li></ul></div><div id="interface"><h1 id="g:1">Differences from Parsec</h1><div class="doc"><p>Compared to Parsec 3, attoparsec makes several tradeoffs.  It is
 not intended for, or ideal for, all possible uses.</p><ul><li>While attoparsec can consume input incrementally, Parsec cannot.
   Incremental input is a huge deal for efficient and secure network
   and system programming, since it gives much more control to users
   of the library over matters such as resource usage and the I/O
   model to use.</li><li>Much of the performance advantage of attoparsec is gained via
   high-performance parsers such as <code><a href="Data-Attoparsec-ByteString.html#v:takeWhile">takeWhile</a></code> and <code><a href="Data-Attoparsec-ByteString.html#v:string">string</a></code>.
   If you use complicated combinators that return lists of bytes or
   characters, there is less performance difference between the two
   libraries.</li><li>Unlike Parsec 3, attoparsec does not support being used as a
   monad transformer.</li><li>attoparsec is specialised to deal only with strict <code><a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></code>
   input.  Efficiency concerns rule out both lists and lazy
   bytestrings.  The usual use for lazy bytestrings would be to
   allow consumption of very large input without a large footprint.
   For this need, attoparsec's incremental input provides an
   excellent substitute, with much more control over when input
   takes place.  If you must use lazy bytestrings, see the
   <a href="Data-Attoparsec-ByteString-Lazy.html">Data.Attoparsec.ByteString.Lazy</a> module, which feeds lazy chunks
   to a regular parser.</li><li>Parsec parsers can produce more helpful error messages than
   attoparsec parsers.  This is a matter of focus: attoparsec avoids
   the extra book-keeping in favour of higher performance.</li></ul></div><h1 id="g:2">Incremental input</h1><div class="doc"><p>attoparsec supports incremental input, meaning that you can feed it
 a bytestring that represents only part of the expected total amount
 of data to parse. If your parser reaches the end of a fragment of
 input and could consume more input, it will suspend parsing and
 return a <code><a href="Data-Attoparsec-ByteString.html#v:Partial">Partial</a></code> continuation.</p><p>Supplying the <code><a href="Data-Attoparsec-ByteString.html#v:Partial">Partial</a></code> continuation with a bytestring will
 resume parsing at the point where it was suspended, with the
 bytestring you supplied used as new input at the end of the
 existing input. You must be prepared for the result of the resumed
 parse to be another <code><a href="Data-Attoparsec-ByteString.html#v:Partial">Partial</a></code> continuation.</p><p>To indicate that you have no more input, supply the <code><a href="Data-Attoparsec-ByteString.html#v:Partial">Partial</a></code>
 continuation with an empty bytestring.</p><p>Remember that some parsing combinators will not return a result
 until they reach the end of input.  They may thus cause <code><a href="Data-Attoparsec-ByteString.html#v:Partial">Partial</a></code>
 results to be returned.</p><p>If you do not need support for incremental input, consider using
 the <code><a href="Data-Attoparsec-ByteString.html#v:parseOnly">parseOnly</a></code> function to run your parser.  It will never
 prompt for more input.</p><p><em>Note</em>: incremental input does <em>not</em> imply that attoparsec will
 release portions of its internal state for garbage collection as it
 proceeds.  Its internal representation is equivalent to a single
 <code>ByteString</code>: if you feed incremental input to a parser, it will
 require memory proportional to the amount of input you supply.
 (This is necessary to support arbitrary backtracking.)</p></div><h1 id="g:3">Performance considerations</h1><div class="doc"><p>If you write an attoparsec-based parser carefully, it can be
 realistic to expect it to perform similarly to a hand-rolled C
 parser (measuring megabytes parsed per second).</p><p>To actually achieve high performance, there are a few guidelines
 that it is useful to follow.</p><p>Use the <code><a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></code>-oriented parsers whenever possible,
 e.g. <code><a href="Data-Attoparsec-ByteString.html#v:takeWhile1">takeWhile1</a></code> instead of <code><a href="Data-Attoparsec-ByteString.html#v:many1">many1</a></code> <code><a href="Data-Attoparsec-ByteString.html#v:anyWord8">anyWord8</a></code>.  There is
 about a factor of 100 difference in performance between the two
 kinds of parser.</p><p>For very simple byte-testing predicates, write them by hand instead
 of using <code><a href="Data-Attoparsec-ByteString.html#v:inClass">inClass</a></code> or <code><a href="Data-Attoparsec-ByteString.html#v:notInClass">notInClass</a></code>.  For instance, both of
 these predicates test for an end-of-line byte, but the first is
 much faster than the second:</p><pre>endOfLine_fast w = w == 13 || w == 10
endOfLine_slow   = inClass &quot;\r\n&quot;</pre><p>Make active use of benchmarking and profiling tools to measure,
 find the problems with, and improve the performance of your parser.</p></div><h1 id="g:4">Parser types</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Parser" class="def">Parser</a> = <a href="Data-Attoparsec-Internal-Types.html#t:Parser">Parser</a> <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></p></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Result" class="def">Result</a> = <a href="Data-Attoparsec-ByteString.html#t:IResult">IResult</a> <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></p></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:IResult" class="def">IResult</a> i r</p><div class="doc"><p>The result of a parse.  This is parameterised over the type <code>i</code>
 of string that was processed.</p><p>This type is an instance of <code><a href="../base-4.8.2.0/Data-Functor.html#t:Functor">Functor</a></code>, where <code><a href="../base-4.8.2.0/Data-Functor.html#v:fmap">fmap</a></code> transforms the
 value in a <code><a href="Data-Attoparsec-ByteString.html#v:Done">Done</a></code> result.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Fail" class="def">Fail</a> i [<a href="../base-4.8.2.0/Data-String.html#t:String">String</a>] <a href="../base-4.8.2.0/Data-String.html#t:String">String</a></td><td class="doc"><p>The parse failed.  The <code>i</code> parameter is the input that had
 not yet been consumed when the failure occurred.  The
 <code>[</code><code><a href="../base-4.8.2.0/Data-String.html#t:String">String</a></code><code>]</code> is a list of contexts in which the error
 occurred.  The <code><a href="../base-4.8.2.0/Data-String.html#t:String">String</a></code> is the message describing the error, if
 any.</p></td></tr><tr><td class="src"><a name="v:Partial" class="def">Partial</a> (i -&gt; <a href="Data-Attoparsec-ByteString.html#t:IResult">IResult</a> i r)</td><td class="doc"><p>Supply this continuation with more input so that the parser
 can resume.  To indicate that no more input is available, pass
 an empty string to the continuation.</p><p><strong>Note</strong>: if you get a <code><a href="Data-Attoparsec-ByteString.html#v:Partial">Partial</a></code> result, do not call its
 continuation more than once.</p></td></tr><tr><td class="src"><a name="v:Done" class="def">Done</a> i r</td><td class="doc"><p>The parse succeeded.  The <code>i</code> parameter is the input that had
 not yet been consumed (if any) when the parse succeeded.</p></td></tr></table></div><div class="subs instances"><p id="control.i:IResult" class="caption collapser" onclick="toggleSection('i:IResult')">Instances</p><div id="section.i:IResult" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><a href="../base-4.8.2.0/Data-Functor.html#t:Functor">Functor</a> (<a href="Data-Attoparsec-ByteString.html#t:IResult">IResult</a> i)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(<a href="../base-4.8.2.0/Text-Show.html#t:Show">Show</a> i, <a href="../base-4.8.2.0/Text-Show.html#t:Show">Show</a> r) =&gt; <a href="../base-4.8.2.0/Text-Show.html#t:Show">Show</a> (<a href="Data-Attoparsec-ByteString.html#t:IResult">IResult</a> i r)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(<a href="../deepseq-1.4.1.1/Control-DeepSeq.html#t:NFData">NFData</a> i, <a href="../deepseq-1.4.1.1/Control-DeepSeq.html#t:NFData">NFData</a> r) =&gt; <a href="../deepseq-1.4.1.1/Control-DeepSeq.html#t:NFData">NFData</a> (<a href="Data-Attoparsec-ByteString.html#t:IResult">IResult</a> i r)</span></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:compareResults" class="def">compareResults</a> :: (<a href="../base-4.8.2.0/Data-Eq.html#t:Eq">Eq</a> i, <a href="../base-4.8.2.0/Data-Eq.html#t:Eq">Eq</a> r) =&gt; <a href="Data-Attoparsec-ByteString.html#t:IResult">IResult</a> i r -&gt; <a href="Data-Attoparsec-ByteString.html#t:IResult">IResult</a> i r -&gt; <a href="../base-4.8.2.0/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a></p><div class="doc"><p>Compare two <code><a href="Data-Attoparsec-ByteString.html#t:IResult">IResult</a></code> values for equality.</p><p>If both <code><a href="Data-Attoparsec-ByteString.html#t:IResult">IResult</a></code>s are <code><a href="Data-Attoparsec-ByteString.html#v:Partial">Partial</a></code>, the result will be <code><a href="../base-4.8.2.0/Data-Maybe.html#v:Nothing">Nothing</a></code>, as
 they are incomplete and hence their equality cannot be known.
 (This is why there is no <code><a href="../base-4.8.2.0/Data-Eq.html#t:Eq">Eq</a></code> instance for <code><a href="Data-Attoparsec-ByteString.html#t:IResult">IResult</a></code>.)</p></div></div><h1 id="g:5">Running parsers</h1><div class="top"><p class="src"><a name="v:parse" class="def">parse</a> :: <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> a -&gt; <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="Data-Attoparsec-ByteString.html#t:Result">Result</a> a</p><div class="doc"><p>Run a parser.</p></div></div><div class="top"><p class="src"><a name="v:feed" class="def">feed</a> :: <a href="../base-4.8.2.0/Data-Monoid.html#t:Monoid">Monoid</a> i =&gt; <a href="Data-Attoparsec-ByteString.html#t:IResult">IResult</a> i r -&gt; i -&gt; <a href="Data-Attoparsec-ByteString.html#t:IResult">IResult</a> i r</p><div class="doc"><p>If a parser has returned a <code><a href="T.html#v:Partial">Partial</a></code> result, supply it with more
 input.</p></div></div><div class="top"><p class="src"><a name="v:parseOnly" class="def">parseOnly</a> :: <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> a -&gt; <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/Data-Either.html#t:Either">Either</a> <a href="../base-4.8.2.0/Data-String.html#t:String">String</a> a</p><div class="doc"><p>Run a parser that cannot be resupplied via a <code><a href="Data-Attoparsec-ByteString.html#v:Partial">Partial</a></code> result.</p><p>This function does not force a parser to consume all of its input.
 Instead, any residual input will be discarded.  To force a parser
 to consume all of its input, use something like this:</p><pre><code><a href="Data-Attoparsec-ByteString.html#v:parseOnly">parseOnly</a></code> (myParser <code><a href="../base-4.8.2.0/Control-Applicative.html#v:-60--42-">&lt;*</a></code> <code><a href="Data-Attoparsec-ByteString.html#v:endOfInput">endOfInput</a></code>)
 </pre></div></div><div class="top"><p class="src"><a name="v:parseWith" class="def">parseWith</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>An action that will be executed to provide the parser
 with more input, if necessary.  The action must return an
 <code><a href="../bytestring-0.10.6.0/Data-ByteString.html#v:empty">empty</a></code> string when there is no more input available.</p></td></tr><tr><td class="src">-&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>Initial input for the parser.</p></td></tr><tr><td class="src">-&gt; m (<a href="Data-Attoparsec-ByteString.html#t:Result">Result</a> a)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Run a parser with an initial input string, and a monadic action
 that can supply more input if needed.</p></div></div><div class="top"><p class="src"><a name="v:parseTest" class="def">parseTest</a> :: <a href="../base-4.8.2.0/Text-Show.html#t:Show">Show</a> a =&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> a -&gt; <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/System-IO.html#t:IO">IO</a> ()</p><div class="doc"><p>Run a parser and print its result to standard output.</p></div></div><h2 id="g:6">Result conversion</h2><div class="top"><p class="src"><a name="v:maybeResult" class="def">maybeResult</a> :: <a href="Data-Attoparsec-ByteString.html#t:Result">Result</a> r -&gt; <a href="../base-4.8.2.0/Data-Maybe.html#t:Maybe">Maybe</a> r</p><div class="doc"><p>Convert a <code><a href="Data-Attoparsec-ByteString.html#t:Result">Result</a></code> value to a <code><a href="../base-4.8.2.0/Data-Maybe.html#t:Maybe">Maybe</a></code> value. A <code><a href="Data-Attoparsec-ByteString.html#v:Partial">Partial</a></code> result
 is treated as failure.</p></div></div><div class="top"><p class="src"><a name="v:eitherResult" class="def">eitherResult</a> :: <a href="Data-Attoparsec-ByteString.html#t:Result">Result</a> r -&gt; <a href="../base-4.8.2.0/Data-Either.html#t:Either">Either</a> <a href="../base-4.8.2.0/Data-String.html#t:String">String</a> r</p><div class="doc"><p>Convert a <code><a href="Data-Attoparsec-ByteString.html#t:Result">Result</a></code> value to an <code><a href="../base-4.8.2.0/Data-Either.html#t:Either">Either</a></code> value. A <code><a href="Data-Attoparsec-ByteString.html#v:Partial">Partial</a></code>
 result is treated as failure.</p></div></div><h1 id="g:7">Parsing individual bytes</h1><div class="top"><p class="src"><a name="v:word8" class="def">word8</a> :: <a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a></p><div class="doc"><p>Match a specific byte.</p></div></div><div class="top"><p class="src"><a name="v:anyWord8" class="def">anyWord8</a> :: <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a></p><div class="doc"><p>Match any byte.</p></div></div><div class="top"><p class="src"><a name="v:notWord8" class="def">notWord8</a> :: <a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a></p><div class="doc"><p>Match any byte except the given one.</p></div></div><div class="top"><p class="src"><a name="v:satisfy" class="def">satisfy</a> :: (<a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a></p><div class="doc"><p>The parser <code>satisfy p</code> succeeds for any byte for which the
 predicate <code>p</code> returns <code><a href="../base-4.8.2.0/Data-Bool.html#v:True">True</a></code>. Returns the byte that is actually
 parsed.</p><pre>digit = satisfy isDigit
    where isDigit w = w &gt;= 48 &amp;&amp; w &lt;= 57</pre></div></div><div class="top"><p class="src"><a name="v:satisfyWith" class="def">satisfyWith</a> :: (<a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a> -&gt; a) -&gt; (a -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> a</p><div class="doc"><p>The parser <code>satisfyWith f p</code> transforms a byte, and succeeds if
 the predicate <code>p</code> returns <code><a href="../base-4.8.2.0/Data-Bool.html#v:True">True</a></code> on the transformed value. The
 parser returns the transformed byte that was parsed.</p></div></div><div class="top"><p class="src"><a name="v:skip" class="def">skip</a> :: (<a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> ()</p><div class="doc"><p>The parser <code>skip p</code> succeeds for any byte for which the predicate
 <code>p</code> returns <code><a href="../base-4.8.2.0/Data-Bool.html#v:True">True</a></code>.</p><pre>skipDigit = skip isDigit
    where isDigit w = w &gt;= 48 &amp;&amp; w &lt;= 57</pre></div></div><h2 id="g:8">Lookahead</h2><div class="top"><p class="src"><a name="v:peekWord8" class="def">peekWord8</a> :: <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> (<a href="../base-4.8.2.0/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a>)</p><div class="doc"><p>Match any byte, to perform lookahead. Returns <code><a href="../base-4.8.2.0/Data-Maybe.html#v:Nothing">Nothing</a></code> if end of
 input has been reached. Does not consume any input.</p><p><em>Note</em>: Because this parser does not fail, do not use it with
 combinators such as <code><a href="../base-4.8.2.0/Control-Applicative.html#v:many">many</a></code>, because such
 parsers loop until a failure occurs.  Careless use will thus result
 in an infinite loop.</p></div></div><div class="top"><p class="src"><a name="v:peekWord8-39-" class="def">peekWord8'</a> :: <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a></p><div class="doc"><p>Match any byte, to perform lookahead.  Does not consume any
 input, but will fail if end of input has been reached.</p></div></div><h2 id="g:9">Byte classes</h2><div class="top"><p class="src"><a name="v:inClass" class="def">inClass</a> :: <a href="../base-4.8.2.0/Data-String.html#t:String">String</a> -&gt; <a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a></p><div class="doc"><p>Match any byte in a set.</p><pre>vowel = inClass &quot;aeiou&quot;</pre><p>Range notation is supported.</p><pre>halfAlphabet = inClass &quot;a-nA-N&quot;</pre><p>To add a literal <code>'-'</code> to a set, place it at the beginning or end
 of the string.</p></div></div><div class="top"><p class="src"><a name="v:notInClass" class="def">notInClass</a> :: <a href="../base-4.8.2.0/Data-String.html#t:String">String</a> -&gt; <a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a></p><div class="doc"><p>Match any byte not in a set.</p></div></div><h1 id="g:10">Efficient string handling</h1><div class="top"><p class="src"><a name="v:string" class="def">string</a> :: <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></p><div class="doc"><p><code>string s</code> parses a sequence of bytes that identically match
 <code>s</code>. Returns the parsed string (i.e. <code>s</code>).  This parser consumes no
 input if it fails (even if a partial match).</p><p><em>Note</em>: The behaviour of this parser is different to that of the
 similarly-named parser in Parsec, as this one is all-or-nothing.
 To illustrate the difference, the following parser will fail under
 Parsec given an input of <code>&quot;for&quot;</code>:</p><pre>string &quot;foo&quot; &lt;|&gt; string &quot;for&quot;</pre><p>The reason for its failure is that the first branch is a
 partial match, and will consume the letters <code>'f'</code> and <code>'o'</code>
 before failing.  In attoparsec, the above parser will <em>succeed</em> on
 that input, because the failed first branch will consume nothing.</p></div></div><div class="top"><p class="src"><a name="v:skipWhile" class="def">skipWhile</a> :: (<a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> ()</p><div class="doc"><p>Skip past input for as long as the predicate returns <code><a href="../base-4.8.2.0/Data-Bool.html#v:True">True</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:take" class="def">take</a> :: <a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a> -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></p><div class="doc"><p>Consume exactly <code>n</code> bytes of input.</p></div></div><div class="top"><p class="src"><a name="v:scan" class="def">scan</a> :: s -&gt; (s -&gt; <a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/Data-Maybe.html#t:Maybe">Maybe</a> s) -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></p><div class="doc"><p>A stateful scanner.  The predicate consumes and transforms a
 state argument, and each transformed state is passed to successive
 invocations of the predicate on each byte of the input until one
 returns <code><a href="../base-4.8.2.0/Data-Maybe.html#v:Nothing">Nothing</a></code> or the input ends.</p><p>This parser does not fail.  It will return an empty string if the
 predicate returns <code><a href="../base-4.8.2.0/Data-Maybe.html#v:Nothing">Nothing</a></code> on the first byte of input.</p><p><em>Note</em>: Because this parser does not fail, do not use it with
 combinators such as <code><a href="../base-4.8.2.0/Control-Applicative.html#v:many">many</a></code>, because such
 parsers loop until a failure occurs.  Careless use will thus result
 in an infinite loop.</p></div></div><div class="top"><p class="src"><a name="v:runScanner" class="def">runScanner</a> :: s -&gt; (s -&gt; <a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/Data-Maybe.html#t:Maybe">Maybe</a> s) -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> (<a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a>, s)</p><div class="doc"><p>Like <code><a href="Data-Attoparsec-ByteString.html#v:scan">scan</a></code>, but generalized to return the final state of the
 scanner.</p></div></div><div class="top"><p class="src"><a name="v:takeWhile" class="def">takeWhile</a> :: (<a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></p><div class="doc"><p>Consume input as long as the predicate returns <code><a href="../base-4.8.2.0/Data-Bool.html#v:True">True</a></code>, and return
 the consumed input.</p><p>This parser does not fail.  It will return an empty string if the
 predicate returns <code><a href="../base-4.8.2.0/Data-Bool.html#v:False">False</a></code> on the first byte of input.</p><p><em>Note</em>: Because this parser does not fail, do not use it with
 combinators such as <code><a href="../base-4.8.2.0/Control-Applicative.html#v:many">many</a></code>, because such
 parsers loop until a failure occurs.  Careless use will thus result
 in an infinite loop.</p></div></div><div class="top"><p class="src"><a name="v:takeWhile1" class="def">takeWhile1</a> :: (<a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></p><div class="doc"><p>Consume input as long as the predicate returns <code><a href="../base-4.8.2.0/Data-Bool.html#v:True">True</a></code>, and return
 the consumed input.</p><p>This parser requires the predicate to succeed on at least one byte
 of input: it will fail if the predicate never returns <code><a href="../base-4.8.2.0/Data-Bool.html#v:True">True</a></code> or if
 there is no input left.</p></div></div><div class="top"><p class="src"><a name="v:takeTill" class="def">takeTill</a> :: (<a href="../base-4.8.2.0/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></p><div class="doc"><p>Consume input as long as the predicate returns <code><a href="../base-4.8.2.0/Data-Bool.html#v:False">False</a></code>
 (i.e. until it returns <code><a href="../base-4.8.2.0/Data-Bool.html#v:True">True</a></code>), and return the consumed input.</p><p>This parser does not fail.  It will return an empty string if the
 predicate returns <code><a href="../base-4.8.2.0/Data-Bool.html#v:True">True</a></code> on the first byte of input.</p><p><em>Note</em>: Because this parser does not fail, do not use it with
 combinators such as <code><a href="../base-4.8.2.0/Control-Applicative.html#v:many">many</a></code>, because such
 parsers loop until a failure occurs.  Careless use will thus result
 in an infinite loop.</p></div></div><h2 id="g:11">Consume all remaining input</h2><div class="top"><p class="src"><a name="v:takeByteString" class="def">takeByteString</a> :: <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a></p><div class="doc"><p>Consume all remaining input and return it as a single string.</p></div></div><div class="top"><p class="src"><a name="v:takeLazyByteString" class="def">takeLazyByteString</a> :: <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.6.0/Data-ByteString-Lazy.html#t:ByteString">ByteString</a></p><div class="doc"><p>Consume all remaining input and return it as a single string.</p></div></div><h1 id="g:12">Combinators</h1><div class="top"><p class="src"><a name="v:try" class="def">try</a> :: <a href="Data-Attoparsec-Internal-Types.html#t:Parser">Parser</a> i a -&gt; <a href="Data-Attoparsec-Internal-Types.html#t:Parser">Parser</a> i a</p><div class="doc"><p>Attempt a parse, and if it fails, rewind the input so that no
 input appears to have been consumed.</p><p>This combinator is provided for compatibility with Parsec.
 attoparsec parsers always backtrack on failure.</p></div></div><div class="top"><p class="src"><a name="v:-60--63--62-" class="def">(&lt;?&gt;)</a> <span class="fixity">infix 0</span><span class="rightedge"></span></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Data-Attoparsec-Internal-Types.html#t:Parser">Parser</a> i a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="../base-4.8.2.0/Data-String.html#t:String">String</a></td><td class="doc"><p>the name to use if parsing fails</p></td></tr><tr><td class="src">-&gt; <a href="Data-Attoparsec-Internal-Types.html#t:Parser">Parser</a> i a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Name the parser, in case failure occurs.</p></div></div><div class="top"><p class="src"><a name="v:choice" class="def">choice</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Alternative">Alternative</a> f =&gt; [f a] -&gt; f a</p><div class="doc"><p><code>choice ps</code> tries to apply the actions in the list <code>ps</code> in order,
 until one of them succeeds. Returns the value of the succeeding
 action.</p></div></div><div class="top"><p class="src"><a name="v:count" class="def">count</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a> -&gt; m a -&gt; m [a]</p><div class="doc"><p>Apply the given action repeatedly, returning every result.</p></div></div><div class="top"><p class="src"><a name="v:option" class="def">option</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Alternative">Alternative</a> f =&gt; a -&gt; f a -&gt; f a</p><div class="doc"><p><code>option x p</code> tries to apply action <code>p</code>. If <code>p</code> fails without
 consuming input, it returns the value <code>x</code>, otherwise the value
 returned by <code>p</code>.</p><pre>priority  = option 0 (digitToInt &lt;$&gt; digit)</pre></div></div><div class="top"><p class="src"><a name="v:many-39-" class="def">many'</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:MonadPlus">MonadPlus</a> m =&gt; m a -&gt; m [a]</p><div class="doc"><p><code>many' p</code> applies the action <code>p</code> <em>zero</em> or more times. Returns a
 list of the returned values of <code>p</code>. The value returned by <code>p</code> is
 forced to WHNF.</p><pre> word  = many' letter</pre></div></div><div class="top"><p class="src"><a name="v:many1" class="def">many1</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Alternative">Alternative</a> f =&gt; f a -&gt; f [a]</p><div class="doc"><p><code>many1 p</code> applies the action <code>p</code> <em>one</em> or more times. Returns a
 list of the returned values of <code>p</code>.</p><pre> word  = many1 letter</pre></div></div><div class="top"><p class="src"><a name="v:many1-39-" class="def">many1'</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:MonadPlus">MonadPlus</a> m =&gt; m a -&gt; m [a]</p><div class="doc"><p><code>many1' p</code> applies the action <code>p</code> <em>one</em> or more times. Returns a
 list of the returned values of <code>p</code>. The value returned by <code>p</code> is
 forced to WHNF.</p><pre> word  = many1' letter</pre></div></div><div class="top"><p class="src"><a name="v:manyTill" class="def">manyTill</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Alternative">Alternative</a> f =&gt; f a -&gt; f b -&gt; f [a]</p><div class="doc"><p><code>manyTill p end</code> applies action <code>p</code> <em>zero</em> or more times until
 action <code>end</code> succeeds, and returns the list of values returned by
 <code>p</code>.  This can be used to scan comments:</p><pre> simpleComment   = string &quot;&lt;!--&quot; *&gt; manyTill anyChar (string &quot;--&gt;&quot;)</pre><p>(Note the overlapping parsers <code>anyChar</code> and <code>string &quot;--&gt;&quot;</code>.
 While this will work, it is not very efficient, as it will cause a
 lot of backtracking.)</p></div></div><div class="top"><p class="src"><a name="v:manyTill-39-" class="def">manyTill'</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:MonadPlus">MonadPlus</a> m =&gt; m a -&gt; m b -&gt; m [a]</p><div class="doc"><p><code>manyTill' p end</code> applies action <code>p</code> <em>zero</em> or more times until
 action <code>end</code> succeeds, and returns the list of values returned by
 <code>p</code>.  This can be used to scan comments:</p><pre> simpleComment   = string &quot;&lt;!--&quot; *&gt; manyTill' anyChar (string &quot;--&gt;&quot;)</pre><p>(Note the overlapping parsers <code>anyChar</code> and <code>string &quot;--&gt;&quot;</code>.
 While this will work, it is not very efficient, as it will cause a
 lot of backtracking.)</p><p>The value returned by <code>p</code> is forced to WHNF.</p></div></div><div class="top"><p class="src"><a name="v:sepBy" class="def">sepBy</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Alternative">Alternative</a> f =&gt; f a -&gt; f s -&gt; f [a]</p><div class="doc"><p><code>sepBy p sep</code> applies <em>zero</em> or more occurrences of <code>p</code>, separated
 by <code>sep</code>. Returns a list of the values returned by <code>p</code>.</p><pre>commaSep p  = p `sepBy` (char ',')</pre></div></div><div class="top"><p class="src"><a name="v:sepBy-39-" class="def">sepBy'</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:MonadPlus">MonadPlus</a> m =&gt; m a -&gt; m s -&gt; m [a]</p><div class="doc"><p><code>sepBy' p sep</code> applies <em>zero</em> or more occurrences of <code>p</code>, separated
 by <code>sep</code>. Returns a list of the values returned by <code>p</code>. The value
 returned by <code>p</code> is forced to WHNF.</p><pre>commaSep p  = p `sepBy'` (char ',')</pre></div></div><div class="top"><p class="src"><a name="v:sepBy1" class="def">sepBy1</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Alternative">Alternative</a> f =&gt; f a -&gt; f s -&gt; f [a]</p><div class="doc"><p><code>sepBy1 p sep</code> applies <em>one</em> or more occurrences of <code>p</code>, separated
 by <code>sep</code>. Returns a list of the values returned by <code>p</code>.</p><pre>commaSep p  = p `sepBy1` (char ',')</pre></div></div><div class="top"><p class="src"><a name="v:sepBy1-39-" class="def">sepBy1'</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:MonadPlus">MonadPlus</a> m =&gt; m a -&gt; m s -&gt; m [a]</p><div class="doc"><p><code>sepBy1' p sep</code> applies <em>one</em> or more occurrences of <code>p</code>, separated
 by <code>sep</code>. Returns a list of the values returned by <code>p</code>. The value
 returned by <code>p</code> is forced to WHNF.</p><pre>commaSep p  = p `sepBy1'` (char ',')</pre></div></div><div class="top"><p class="src"><a name="v:skipMany" class="def">skipMany</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Alternative">Alternative</a> f =&gt; f a -&gt; f ()</p><div class="doc"><p>Skip zero or more instances of an action.</p></div></div><div class="top"><p class="src"><a name="v:skipMany1" class="def">skipMany1</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Alternative">Alternative</a> f =&gt; f a -&gt; f ()</p><div class="doc"><p>Skip one or more instances of an action.</p></div></div><div class="top"><p class="src"><a name="v:eitherP" class="def">eitherP</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Alternative">Alternative</a> f =&gt; f a -&gt; f b -&gt; f (<a href="../base-4.8.2.0/Data-Either.html#t:Either">Either</a> a b)</p><div class="doc"><p>Combine two alternatives.</p></div></div><div class="top"><p class="src"><a name="v:match" class="def">match</a> :: <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> a -&gt; <a href="Data-Attoparsec-ByteString.html#t:Parser">Parser</a> (<a href="../bytestring-0.10.6.0/Data-ByteString.html#t:ByteString">ByteString</a>, a)</p><div class="doc"><p>Return both the result of a parse and the portion of the input
 that was consumed while it was being parsed.</p></div></div><h1 id="g:13">State observation and manipulation functions</h1><div class="top"><p class="src"><a name="v:endOfInput" class="def">endOfInput</a> :: <span class="keyword">forall</span> t. <a href="Data-Attoparsec-Internal-Types.html#t:Chunk">Chunk</a> t =&gt; <a href="Data-Attoparsec-Internal-Types.html#t:Parser">Parser</a> t ()</p><div class="doc"><p>Match only if all input has been consumed.</p></div></div><div class="top"><p class="src"><a name="v:atEnd" class="def">atEnd</a> :: <a href="Data-Attoparsec-Internal-Types.html#t:Chunk">Chunk</a> t =&gt; <a href="Data-Attoparsec-Internal-Types.html#t:Parser">Parser</a> t <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a></p><div class="doc"><p>Return an indication of whether the end of input has been
 reached.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>